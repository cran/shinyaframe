(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';'Copyright 2017 William Murphy This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.';if('undefined'==typeof AFRAME)throw new Error('Component attempted to register before AFRAME was available.');require('three-instanced-mesh')(window.THREE),require('./src/plot.js'),require('./src/theme.js'),require('./src/data-binding.js'),require('./src/layer-point.js'),require('./src/layer-point-entity.js'),require('./src/guide-axis.js'),require('./src/guide-legend.js'),require('./src/scale-shape.js'),require('./src/mod-oscillate.js');

},{"./src/data-binding.js":19,"./src/guide-axis.js":20,"./src/guide-legend.js":21,"./src/layer-point-entity.js":22,"./src/layer-point.js":23,"./src/mod-oscillate.js":24,"./src/plot.js":25,"./src/scale-shape.js":27,"./src/theme.js":28,"three-instanced-mesh":8}],2:[function(require,module,exports){
function cubicInOut(t) {
  return t < 0.5
    ? 4.0 * t * t * t
    : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0
}

module.exports = cubicInOut
},{}],3:[function(require,module,exports){
function linear(t) {
  return t
}

module.exports = linear
},{}],4:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],5:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],6:[function(require,module,exports){
var lerp = require('lerp')

module.exports = function lerpValues(value1, value2, t, out) {
    if (typeof value1 === 'number'
            && typeof value2 === 'number')
        return lerp(value1, value2, t)
    else { //assume array
        var len = Math.min(value1.length, value2.length)
        out = out||new Array(len)
        for (var i=0; i<len; i++) 
            out[i] = lerp(value1[i], value2[i], t)
        return out
    }
}
},{"lerp":7}],7:[function(require,module,exports){
function lerp(v0, v1, t) {
    return v0*(1-t)+v1*t
}
module.exports = lerp
},{}],8:[function(require,module,exports){
/**************************
 * Dusan Bosnjak @pailhead
 **************************/
 
module.exports = function( THREE ){

//monkeypatch shaders
require('./monkey-patch.js')(THREE);

//depth mat
var depthMaterial = new THREE.MeshDepthMaterial();

depthMaterial.depthPacking = THREE.RGBADepthPacking;

depthMaterial.clipping = true;

depthMaterial.defines = {

	INSTANCE_TRANSFORM: ''

};

//distance mat
var 
	
	distanceShader = THREE.ShaderLib[ "distanceRGBA" ],
	distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms ),
	distanceMaterial = new THREE.ShaderMaterial( {
		defines: {
			'USE_SHADOWMAP': '',
			'INSTANCE_TRANSFORM': ''
		},
		uniforms: distanceUniforms,
		vertexShader: distanceShader.vertexShader,
		fragmentShader: distanceShader.fragmentShader,
		clipping: true
	})
;

//main class
THREE.InstancedMesh = function ( bufferGeometry , material , numInstances , dynamic , colors , uniformScale ) {

	THREE.Mesh.call( this , (new THREE.InstancedBufferGeometry()).copy( bufferGeometry ) ); //hacky for now

	this._dynamic = !!dynamic; //TODO: set a bit mask for different attributes?

 	this._uniformScale = !!uniformScale;

 	this._colors = !!colors;

	this.numInstances = numInstances;

	this._setAttributes();

	/**
	 * use the setter to decorate this material
	 * this is in lieu of changing the renderer
	 * WebGLRenderer injects stuff like this
	 */
	this.material = material.clone();
 	
	this.frustumCulled = false; //you can uncheck this if you generate your own bounding info

	//make it work with depth effects
	this.customDepthMaterial = depthMaterial; 

	this.customDistanceMaterial = distanceMaterial;

}

THREE.InstancedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.InstancedMesh.constructor = THREE.InstancedMesh;

//this is kinda gnarly, done in order to avoid setting these defines in the WebGLRenderer (it manages most if not all of the define flags)
Object.defineProperties( THREE.InstancedMesh.prototype , {

	'material': {

		set: function( m ){ 

			/**
			 * whenever a material is set, decorate it, 
			 * if a material used with regular geometry is passed, 
			 * it will mutate it which is bad mkay
			 *
			 * either flag Material with these instance properties:
			 * 
			 *  "i want to create a RED PLASTIC material that will
			 *   be INSTANCED and i know it will be used on clones
			 *   that are known to be UNIFORMly scaled"
			 *  (also figure out where dynamic fits here)
			 *  
			 * or check here if the material has INSTANCE_TRANSFORM
			 * define set, if not, clone, document that it breaks reference
			 * or do a shallow copy or something
			 * 
			 * or something else?
			 */
			m = m.clone();

			if ( m.defines ) {
				
				m.defines.INSTANCE_TRANSFORM = '';
				
				if ( this._uniformScale ) m.defines.INSTANCE_UNIFORM = ''; //an optimization, should avoid doing an expensive matrix inverse in the shader
				else delete m.defines['INSTANCE_UNIFORM'];

				if ( this._colors ) m.defines.INSTANCE_COLOR = '';
				else delete m.defines['INSTANCE_COLOR'];
			}

			else{ 
			
				m.defines = { INSTANCE_TRANSFORM: '' };

				if ( this._uniformScale ) m.defines.INSTANCE_UNIFORM = '';
				if ( this._colors ) m.defines.INSTANCE_COLOR = '';
			}

			this._material = m;

		},

		get: function(){ return this._material; }

	},

	//force new attributes to be created when set?
	'numInstances': {

		set: function( v ){ 

			this._numInstances = v;

			//reset buffers

			this._setAttributes();

		},

		get: function(){ return this._numInstances; }

	},

	//do some auto-magic when BufferGeometry is set
	//TODO: account for Geometry, or change this approach completely 
	'geometry':{

		set: function( g ){ 

			//if its not already instanced attach buffers
			if ( !!g.attributes.instancePosition ) {

				this._geometry = new THREE.InstancedBufferGeometry();

				this._setAttributes();

			} 

			else 

				this._geometry = g;

		},

		get: function(){ return this._geometry; }

	}

});

THREE.InstancedMesh.prototype.setPositionAt = function( index , position ){

	this.geometry.attributes.instancePosition.setXYZ( index , position.x , position.y , position.z );

};

THREE.InstancedMesh.prototype.setQuaternionAt = function ( index , quat ) {

	this.geometry.attributes.instanceQuaternion.setXYZW( index , quat.x , quat.y , quat.z , quat.w );

};

THREE.InstancedMesh.prototype.setScaleAt = function ( index , scale ) {

	this.geometry.attributes.instanceScale.setXYZ( index , scale.x , scale.y , scale.z );

};

THREE.InstancedMesh.prototype.setColorAt = function ( index , color ) {

	if( !this._colors ) {

		console.warn( 'THREE.InstancedMesh: color not enabled');

		return;

	}

	this.geometry.attributes.instanceColor.setXYZ( 
		index , 
		Math.floor( color.r * 255 ), 
		Math.floor( color.g * 255 ), 
		Math.floor( color.b * 255 )
	);

};

THREE.InstancedMesh.prototype.getPositionAt = function( index , position ){

	var arr = this.geometry.attributes.instancePosition.array;

	index *= 3;

	return position ? 

		position.set( arr[index++], arr[index++], arr[index] ) :

		new THREE.Vector3(  arr[index++], arr[index++], arr[index] )
	;
	
};

THREE.InstancedMesh.prototype.getQuaternionAt = function ( index , quat ) {

	var arr = this.geometry.attributes.instanceQuaternion.array;

	index = index << 2;

	return quat ? 

		quat.set(       arr[index++], arr[index++], arr[index++], arr[index] ) :

		new THREE.Quaternion( arr[index++], arr[index++], arr[index++], arr[index] )
	;
	
};

THREE.InstancedMesh.prototype.getScaleAt = function ( index , scale ) {

	var arr = this.geometry.attributes.instanceScale.array;

	index *= 3;

	return scale ? 

		scale.set(   arr[index++], arr[index++], arr[index] ) :

		new THREE.Vector3( arr[index++], arr[index++], arr[index] )
	;

};

THREE.InstancedMesh.prototype.getColorAt = (function(){

	var inv255 = 1/255;

	return function ( index , color ) {

		if( !this._colors ) {

			console.warn( 'THREE.InstancedMesh: color not enabled');

			return false;

		}

		var arr = this.geometry.attributes.instanceColor.array;
		
		index *= 3;

		return color ? 

			color.setRGB( arr[index++] * inv255, arr[index++] * inv255, arr[index] * inv255 ) :

			new THREE.Vector3( arr[index++], arr[index++], arr[index] ).multiplyScalar( inv255 )
		;

	};

})()

THREE.InstancedMesh.prototype.needsUpdate = function( attribute ){

	switch ( attribute ){

		case 'position' :

			this.geometry.attributes.instancePosition.needsUpdate =   true;

			break;

		case 'quaternion' :

			this.geometry.attributes.instanceQuaternion.needsUpdate = true;

			break;

		case 'scale' :

			this.geometry.attributes.instanceScale.needsUpdate =      true;

			break;

		case 'colors' :

			this.geometry.attributes.instanceColor.needsUpdate =      true;

		default:

			this.geometry.attributes.instancePosition.needsUpdate =   true;
			this.geometry.attributes.instanceQuaternion.needsUpdate = true;
			this.geometry.attributes.instanceScale.needsUpdate =      true;
			this.geometry.attributes.instanceColor.needsUpdate =      true;

			break;

	}

};

THREE.InstancedMesh.prototype._setAttributes = function(){

	this.geometry.addAttribute( 'instancePosition' , 	new THREE.InstancedBufferAttribute( new Float32Array( this.numInstances * 3 ) , 3 , 1 ) ); 
	this.geometry.addAttribute( 'instanceQuaternion' , 	new THREE.InstancedBufferAttribute( new Float32Array( this.numInstances * 4 ) , 4 , 1 ) );
	this.geometry.addAttribute( 'instanceScale' , 		new THREE.InstancedBufferAttribute( new Float32Array( this.numInstances * 3 ) , 3 , 1 ) );

	//TODO: allow different combinations
	this.geometry.attributes.instancePosition.dynamic = this._dynamic;
	this.geometry.attributes.instanceQuaternion.dynamic = this._dynamic;
	this.geometry.attributes.instanceScale.dynamic = this._dynamic;
	
	if ( this._colors ){

		this.geometry.addAttribute( 'instanceColor' , 	new THREE.InstancedBufferAttribute( new Uint8Array( this.numInstances * 3 ) , 3 , 1 ) );
		this.geometry.attributes.instanceColor.normalized = true;
		this.geometry.attributes.instanceColor.dynamic = this._dynamic;

	}	

};

return THREE.InstancedMesh;

};

},{"./monkey-patch.js":9}],9:[function(require,module,exports){
/**************************
 * Dusan Bosnjak @pailhead
 **************************/

module.exports = function ( THREE ){

	if( /InstancedMesh/.test( THREE.REVISION ) ) return THREE;

	require('./monkey-patch/index.js')( THREE );

	THREE.REVISION += "_InstancedMesh";

	return THREE;

}
},{"./monkey-patch/index.js":15}],10:[function(require,module,exports){
/**************************
 * Dusan Bosnjak @pailhead
 **************************/

// transform vertices with the transform matrix

module.exports = [

"#ifndef INSTANCE_TRANSFORM",

"vec3 transformed = vec3( position );",

"#else",

"#ifndef INSTANCE_MATRIX",

	"mat4 _instanceMatrix = getInstanceMatrix();",

	"#define INSTANCE_MATRIX",

"#endif",

"vec3 transformed = ( getInstanceMatrix() * vec4( position , 1. )).xyz;",

"#endif",

].join("\n")
},{}],11:[function(require,module,exports){
/**************************
 * Dusan Bosnjak @pailhead
 **************************/

// multiply the color with per instance color if enabled

module.exports = [

'#ifdef USE_COLOR',

	'diffuseColor.rgb *= vColor;',

'#endif',

'#ifdef INSTANCE_COLOR ',
		
	'diffuseColor.rgb *= vInstanceColor;',
		
'#endif'

].join("\n")
},{}],12:[function(require,module,exports){
/**************************
 * Dusan Bosnjak @pailhead
 **************************/

// add fragment varying if feature enabled

module.exports = [

"#ifdef USE_COLOR",

	"varying vec3 vColor;",

"#endif",

"#if defined( INSTANCE_COLOR )",
		
	"varying vec3 vInstanceColor;",
		
"#endif"

].join("\n")
},{}],13:[function(require,module,exports){
/**************************
 * Dusan Bosnjak @pailhead
 **************************/

// read per instance color from attribute, pass to varying

module.exports = [

"#ifdef USE_COLOR",

	"vColor.xyz = color.xyz;",

"#endif",

"#if defined( INSTANCE_COLOR ) && defined( INSTANCE_TRANSFORM )",
		
	"vInstanceColor = instanceColor;",
		
"#endif",

].join("\n")
},{}],14:[function(require,module,exports){
/**************************
 * Dusan Bosnjak @pailhead
 **************************/

module.exports = [

"#ifdef FLIP_SIDED",

	"objectNormal = -objectNormal;",

"#endif",

"#ifndef INSTANCE_TRANSFORM",

	"vec3 transformedNormal = normalMatrix * objectNormal;",

"#else",

	"#ifndef INSTANCE_MATRIX ",

		"mat4 _instanceMatrix = getInstanceMatrix();",

		"#define INSTANCE_MATRIX",

	"#endif",

	"#ifndef INSTANCE_UNIFORM",
	
		"vec3 transformedNormal =  transpose( inverse( mat3( modelViewMatrix * _instanceMatrix ) ) ) * objectNormal ;",

	"#else",

		"vec3 transformedNormal = ( modelViewMatrix * _instanceMatrix * vec4( objectNormal , 0.0 ) ).xyz;",

	"#endif",

"#endif"

].join("\n");
},{}],15:[function(require,module,exports){
/**************************
 * Dusan Bosnjak @pailhead
 **************************/

module.exports = function( THREE ){

	//patches these methods and shader chunks with the required logic 
	THREE.ShaderChunk[ 'begin_vertex' ] = 				require('./begin_vertex.glsl.js'); 
	THREE.ShaderChunk[ 'color_fragment' ] = 			require('./color_fragment.glsl.js');
	THREE.ShaderChunk[ 'color_pars_fragment.glsl' ] = 	require('./color_pars_fragment.glsl.js');
	THREE.ShaderChunk[ 'color_vertex.glsl' ] = 			require('./color_vertex.glsl.js');
	THREE.ShaderChunk[ 'defaultnormal_vertex' ] = 		require('./defaultnormal_vertex.glsl.js');
	THREE.ShaderChunk[ 'uv_pars_vertex' ] = 			require('./uv_pars_vertex.glsl.js');
	
}
},{"./begin_vertex.glsl.js":10,"./color_fragment.glsl.js":11,"./color_pars_fragment.glsl.js":12,"./color_vertex.glsl.js":13,"./defaultnormal_vertex.glsl.js":14,"./uv_pars_vertex.glsl.js":16}],16:[function(require,module,exports){
/**************************
 * Dusan Bosnjak @pailhead
 **************************/

module.exports = [

"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )",
 
  "varying vec2 vUv;",
  
  "uniform vec4 offsetRepeat;",

"#endif",

"#ifdef INSTANCE_TRANSFORM",

"mat3 inverse(mat3 m) {",

  "float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];",

  "float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];",

  "float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];",

  "float b01 = a22 * a11 - a12 * a21;",

  "float b11 = -a22 * a10 + a12 * a20;",

  "float b21 = a21 * a10 - a11 * a20;",

  "float det = a00 * b01 + a01 * b11 + a02 * b21;",

  "return mat3(b01, (-a22 * a01 + a02 * a21), ( a12 * a01 - a02 * a11),",
              "b11, ( a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),",
              "b21, (-a21 * a00 + a01 * a20), ( a11 * a00 - a01 * a10)) / det;",
"}",

//for dynamic, avoid computing the matrices on the cpu
"attribute vec3 instancePosition;",
"attribute vec4 instanceQuaternion;",
"attribute vec3 instanceScale;",

"#if defined( INSTANCE_COLOR )",
  "attribute vec3 instanceColor;",
  "varying vec3 vInstanceColor;",
"#endif",

"mat4 getInstanceMatrix(){",

  "vec4 q = instanceQuaternion;",
  "vec3 s = instanceScale;",
  "vec3 v = instancePosition;",

  "vec3 q2 = q.xyz + q.xyz;",
  "vec3 a = q.xxx * q2.xyz;",
  "vec3 b = q.yyz * q2.yzz;",
  "vec3 c = q.www * q2.xyz;",

  "vec3 r0 = vec3( 1.0 - (b.x + b.z) , a.y + c.z , a.z - c.y ) * s.xxx;",
  "vec3 r1 = vec3( a.y - c.z , 1.0 - (a.x + b.z) , b.y + c.x ) * s.yyy;",
  "vec3 r2 = vec3( a.z + c.y , b.y - c.x , 1.0 - (a.x + b.x) ) * s.zzz;",

  "return mat4(",

      "r0 , 0.0,",
      "r1 , 0.0,",
      "r2 , 0.0,",
      "v  , 1.0",

  ");",

"}",

"#endif"

].join("\n");


},{}],17:[function(require,module,exports){
var BaseTween = require('tween-base')
var lerp = require('lerp-array')
var inherits = require('inherits')

function ArrayTween(target, end, opt) {
    if (!(this instanceof ArrayTween))
        return new ArrayTween(target, end, opt)

    if (typeof opt === 'number')
        opt = { duration: opt }
    
    BaseTween.call(this, opt)
    this.target = target
    this.start = (opt && opt.start) || this.target
    this.end = end
}

inherits(ArrayTween, BaseTween)

ArrayTween.prototype.ready = function() {
    if (this.target === this.start)
        this.start = this.target.slice()
}

ArrayTween.prototype.lerp = function(alpha) {
    lerp(this.start, this.end, alpha, this.target)
}

module.exports = ArrayTween
},{"inherits":5,"lerp-array":6,"tween-base":18}],18:[function(require,module,exports){
var noop = function(){}
var linear = require('eases/linear')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')

function BaseTween(opt) {
    EventEmitter.call(this)

    //users generally don't need to change these
    this.duration = (opt && opt.duration)||0
    this.delay = (opt && opt.delay)||0
    this.time = 0
    this.ease = opt && opt.ease
    this.active = true
    this.enabled = true
    this.cancelling = false
    this._started = false
}

inherits(BaseTween, EventEmitter)

BaseTween.prototype.lerp = noop
BaseTween.prototype.ready = noop

BaseTween.prototype.cancel = function() {
    this.cancelling = true
    return this
}

BaseTween.prototype.tick = function(dt, ease) {
    ease = typeof ease === 'function' ? ease : defaultEase

    if (this.cancelling && this.active) {
        this.active = false
        this.emit('cancelling', this)
        this.emit('complete', this)
    }

    if (!this.active || !this.enabled)
        return

    var last = this.time
    this.time += dt
            
    var alpha = (this.time-this.delay) / this.duration
    if (this.time-this.delay > 0) {
        if (!this._started) {
            this._started = true
            this.ready()
            this.emit('start', this)
        }

        if (alpha < 0)
            alpha = 0
        else if (alpha > 1)
            alpha = 1
        alpha = ease(this, alpha)
        this.lerp(alpha)
        this.emit('update', this)
    }

    if (this.time >= (this.duration+this.delay)) {
        this.active = false
        this.emit('complete', this)
    }
}

function defaultEase(tween, alpha) {
    if (typeof tween.ease === 'function')
        return tween.ease(alpha)
    return linear(alpha)
}

module.exports = BaseTween
},{"eases/linear":3,"events":4,"inherits":5}],19:[function(require,module,exports){
'use strict';AFRAME.registerSystem('data-binding',{schema:{},init:function(){this.bindings={},this.sourceData={},this.updateDataListenerBound=this.updateDataListener.bind(this),this.el.addEventListener('update-data',this.updateDataListenerBound),this.dirtyTargets=new Set,this.dirtyComps=new Set},remove:function(){this.el.removeEventListener('update-data',this.updateDataListenerBound)},updateData:function(a){for(let b in this.dirtyTargets.clear(),this.dirtyComps.clear(),this.bindings)if(a[b]){let c=this.sourceData[b];c!==a[b]&&(c.length=0,c.push(...a[b])),this.bindings[b].forEach((a)=>{if(this.dirtyComps.add(a),a.data.target.length){const b=a.el.components[a.targetName];b&&(this.dirtyTargets.add(b),b.data[a.targetProp]=c)}}),delete a[b]}for(let b of this.dirtyTargets)b.update(b.data);for(let b of this.dirtyComps)b.publishUpdate();this.sourceData=AFRAME.utils.extend(this.sourceData,a)},updateDataListener:function(a){this.updateData(a.detail.data)},bindData:function(a){const b=a.data.source;if(''!==b)return this.sourceData[b]||(this.sourceData[b]=[]),this.bindings[b]?this.bindings[b].push(a):this.bindings[b]=[a],this.sourceData[b]},unbindData:function(a){let b=this.bindings[a.data.source];if(b){let c=b.indexOf(a);-1!==c&&this.bindings[a.data.source].splice(c,1)}}}),AFRAME.registerComponent('data-binding',{schema:{source:{type:'string'},target:{type:'string'}},multiple:!0,init:function(){this.boundData=null,this.targetName=null,this.targetProp=null,this.updateDetails={boundData:this.boundData}},update:function(a){0===this.data.source.length&&(this.data.source=this.id),a.source!==this.data.source&&(this.system.unbindData(this),this.boundData=this.system.bindData(this)),this.data.target.length&&([this.targetName,this.targetProp]=this.data.target.split('.'))},remove:function(){this.system.unbindData(this)},publishUpdate:function(){this.el.emit('data-changed',this.updateDetails)}});

},{}],20:[function(require,module,exports){
'use strict';AFRAME.registerComponent('guide-axis',{schema:{axis:{default:'x',oneOf:['x','y','z']},title:{default:[]},breaks:{default:[]},labels:{default:[]}},dependencies:['theme'],init:function(){this.nextMark=0,this.numMarks=0,this.markEls=[],this.markScale={},this.el.axis=this.data.axis;const a={x:0,y:0,z:0},b={x:0,y:0,z:0},c=this.data,d=this.el.components.theme.getTheme();switch(c.axis){case'x':a.x=-0.5,a.y=-0.515,a.z=0.515,b.x=-45;break;case'y':a.x=0.515,a.y=-0.5,a.z=0.515,b.y=-45;break;case'z':a.y=-0.515,a.x=-0.515,a.z=-0.5,b.z=-45;}this.markArea=document.createElement('a-entity'),this.el.appendChild(this.markArea),this.markArea.setAttribute('position',a),this.markArea.setAttribute('rotation',b),this.titleEl=document.createElement('a-entity'),this.markArea.appendChild(this.titleEl),this.titleEl.setAttribute('text',{font:d.font,color:d.fontColor,align:'y'===c.axis?'left':'center',anchor:'y'===c.axis?'left':'center'}),this.titleEl.setAttribute('rotation',{x:0,y:'z'===c.axis?-90:0,z:0}),this.titleEl.setAttribute('position',{x:'x'===c.axis?0.5:0,y:'y'===c.axis?1.03:-0.03,z:'z'===c.axis?0.5:-0.03})},update:function(){if(this.nextMark=0,this.numMarks=this.data.breaks.length,this.theme=this.el.components.theme.getTheme(),this.markScale.x=this.markScale.y=this.markScale.z=this.theme.fontScale,'number'!=typeof this.data.breaks[0])for(let a in this.data.breaks)this.data.breaks[a]=parseFloat(this.data.breaks[a]);this.titleEl.setAttribute('text',{value:this.data.title[0]||'(unmapped)'})},tick:function(){let a;const b=this.numMarks,c=this.nextMark;if(this.markEls.length>b)return this.markArea.removeChild(this.markEls[b]),void this.markEls.splice(b,1);if(!(c>=b)){this.nextMark>=this.markEls.length?(a=document.createElement('a-entity'),this.markEls.push(a),this.markArea.appendChild(a)):a=this.markEls[c];const b=this.data.axis,d=this.data.labels[c],e={x:0,y:0,z:0},f={x:0,y:'z'===b?-90:0,z:0};e[b]+=this.data.breaks[c],a.setAttribute('position',e),a.setAttribute('rotation',f),a.setAttribute('scale',this.markScale),a.setAttribute('text',{font:this.theme.font,value:d,color:this.theme.fontColor,align:'y'===this.data.axis?'left':'center',anchor:'y'===this.data.axis?'left':'center'}),this.nextMark++}}});

},{}],21:[function(require,module,exports){
'use strict';const helpers=require('./plotutils');AFRAME.registerComponent('guide-legend',{schema:{aesthetic:{default:'color',oneOf:['shape','size','color']},title:{default:[]},breaks:{default:[]},labels:{default:[]}},dependencies:['theme'],init:function(){const a=this.el.components.theme.getTheme();this.nextMark=0,this.numMarks=0,this.markEls=[],this.labelEls=[],this.fontScale={},this.titleEl=document.createElement('a-entity'),this.el.appendChild(this.titleEl),this.titleEl.setAttribute('position',{x:0,y:a.guideHeight/2-a.guideMargin,z:0}),this.titleEl.setAttribute('text',{font:a.font,align:'center'}),this.markArea=document.createElement('a-entity'),this.el.appendChild(this.markArea),this.labelArea=document.createElement('a-entity'),this.el.appendChild(this.labelArea),helpers.getPlot(this.el).then((a)=>{this.plot=a,this.updateDelayed&&this.update()}).catch((a)=>{throw a})},update:function(){if(!this.plot)return void(this.updateDelayed=!0);this.nextMark=0,this.breaks=this.data.breaks,this.labels=this.data.labels;const a=this.plot.scales.get(this.data.aesthetic);let b;a&&(b=a.getScaleInfo(),this.breaks=this.breaks.length?this.breaks:b.breaks,this.labels=this.labels.length?this.labels:b.labels),this.numMarks=this.breaks.length,this.updateDelayed=!1,this.theme=this.el.components.theme.getTheme(),this.theme.titleSpace=0.03,this.titleEl.setAttribute('text',{value:this.data.title[0]||'('+this.data.aesthetic+' not mapped)',color:this.theme.fontColor}),this.fontScale.x=this.fontScale.y=this.fontScale.z=this.theme.fontScale;let c=this.theme.size;'size'===this.data.aesthetic&&(c*=Math.max(...this.data.breaks)||1),this.markArea.setAttribute('position',{x:this.theme.guideWidth/2-this.theme.guideMargin-c,y:this.theme.guideHeight/2-this.theme.guideMargin-0.03,z:this.theme.guideMargin}),this.labelArea.setAttribute('position',{x:this.theme.guideWidth/2-2*(this.theme.guideMargin+c),y:this.theme.guideHeight/2-this.theme.guideMargin,z:0})},tick:function(){if(this.updateDelayed)return;let a,b;const c=this.numMarks,d=this.nextMark;if(this.markEls.length>c)return this.markArea.removeChild(this.markEls[c]),this.labelArea.removeChild(this.labelEls[c]),this.markEls.splice(c,1),void this.labelEls.splice(c,1);if(!(d>=c)){this.nextMark>=this.markEls.length?(a=document.createElement('a-entity'),this.markEls.push(a),this.markArea.appendChild(a),b=document.createElement('a-entity'),this.labelEls.push(b),this.labelArea.appendChild(b)):(a=this.markEls[d],b=this.labelEls[d]);const c=this.data.aesthetic,e=this.theme,f=this.labels[d]||this.breaks[d],g={x:0,y:-d*(e.guideHeight-e.titleSpace)/this.numMarks-e.titleSpace,z:0},h={x:0,y:g.y+0.02,z:0},j='shape'===c?this.breaks[d]:e.shape,k='size'===c?this.breaks[d]:1,l='color'===c?this.breaks[d]:e.color;b.setAttribute('scale',this.fontScale),b.setAttribute('position',g),b.setAttribute('text',{font:e.font,value:f,anchor:'right',align:'right',baseline:'top',color:e.fontColor}),a.setAttribute('position',h),a.setAttribute('geometry',helpers.makeGeometry(j,e.size)),a.setAttribute('scale',{x:k,y:k,z:k}),a.setAttribute('material',helpers.makeMaterial(l)),this.nextMark++}}});

},{"./plotutils":26}],22:[function(require,module,exports){
'use strict';const helpers=require('./plotutils');AFRAME.registerComponent('layer-point-entity',{schema:{x:{type:'array'},y:{type:'array'},z:{type:'array'},shape:{type:'array'},size:{type:'array'},color:{type:'array'}},dependencies:['theme'],init:function(){this.nextMark=0,this.numMarks=0,this.markEls=[],this.el.setAttribute('position',{x:-0.5,y:-0.5,z:-0.5}),helpers.getPlot(this.el).then((a)=>{this.plot=a,this.updateDelayed&&this.update()}).catch((a)=>{throw a})},update:function(){return this.plot?void(this.nextMark=0,this.numMarks=this.data.x.length,this.theme=this.el.components.theme.getTheme(),this.shapeScaled=this.plot.scales.get('shape').scale(this.data.shape)):void(this.updateDelayed=!0)},tick:function(){let a;const b=this.numMarks,c=this.nextMark;if(this.markEls.length>b)return this.el.removeChild(this.markEls[b]),void this.markEls.splice(b,1);if(!(c>=b)){this.nextMark>=this.markEls.length?(a=document.createElement('a-entity'),this.markEls.push(a),this.el.appendChild(a)):a=this.markEls[c],a.setAttribute('geometry',helpers.makeGeometry(this.shapeScaled[1===this.data.shape.length?0:c]||this.theme.shape,this.theme.size));const b=this.data.size[1===this.data.size.length?0:c]||1;a.setAttribute('scale',{x:b,y:b,z:b}),a.setAttribute('material',helpers.makeMaterial(this.data.color[1===this.data.color.length?0:c]||this.theme.color)),a.setAttribute('position',{x:this.data.x[c],y:this.data.y[c],z:this.data.z[c]}),this.nextMark++}}});

},{"./plotutils":26}],23:[function(require,module,exports){
'use strict';const helpers=require('./plotutils');AFRAME.registerComponent('layer-point',{schema:{x:{type:'array'},y:{type:'array'},z:{type:'array'},shape:{type:'array'},size:{type:'array'},color:{type:'array'},spin:{type:'array'}},dependencies:['theme'],init:function(){this.numMarks=0,this.lastGroups=new Map,this.el.setAttribute('position',{x:-0.5,y:-0.5,z:-0.5}),helpers.getPlot(this.el).then((a)=>{this.plot=a,this.updateDelayed&&this.update()}).catch((a)=>{throw a})},update:function(){if(!this.plot)return void(this.updateDelayed=!0);this.numMarks=this.data.x.length,this.theme=this.el.components.theme.getTheme();for(let[a]of this.lastGroups){const b=this.el.getObject3D(a);this.el.removeObject3D(a),b.material.dispose(),b.geometry.dispose()}if(this.lastGroups.clear(),this.shapeScaled=this.plot.scales.get('shape').scale(this.data.shape),1>this.numMarks)return;let a,b;this.shapeScaled.length<this.numMarks&&(a=this.shapeScaled[0]||this.theme.shape),this.data.color.length<this.numMarks&&(b=this.data.color[0]||this.theme.color);const c=helpers.findGeometryGroups(a||this.shapeScaled,b||this.data.color,this.numMarks),d={};for(let[a]of c)d[a]=0;const e=new THREE.Quaternion,f=new THREE.Vector3;for(let g=0;g<this.numMarks;g++){const h=a||this.shapeScaled[g],i=b||this.data.color[g],j=h+i;let k=this.el.getObject3D(j);k||(k=new THREE.InstancedMesh(helpers.makeThreeGeometry(h,this.theme.size),new THREE.MeshLambertMaterial({color:i}),c.get(j).length,!0,!1,!1),this.el.setObject3D(j,k));const l=d[j];k.setPositionAt(l,f.set(this.data.x[g],this.data.y[g],this.data.z[g])),k.setQuaternionAt(l,e);const m=this.data.size[1===this.data.size.length?0:g]||1;k.setScaleAt(l,f.setScalar(m)),d[j]++}for(let[a]of c){const b=this.el.getObject3D(a);b.needsUpdate('position'),b.needsUpdate('quaternion'),b.needsUpdate('scale')}this.lastGroups=c,this.el.emit('layer-updated','layer-point',!1)},tick:function(){var a=Math.PI;const b=new THREE.Quaternion,c=new THREE.Euler;return function(d,e){let f;if(!(this.data.spin.length<this.numMarks&&(f=this.data.spin[0]||this.theme.spin,!f))){c.set(0,0.1,0);for(let[d,g]of this.lastGroups){let h=this.el.getObject3D(d);for(let d,i=0;i<g.length;i++)d=g[i],h.getQuaternionAt(i,b),c.setFromQuaternion(b),c.y+=(f||this.data.spin[d])*(e/1e3),c.y>=a/2&&(c.y-=a),b.setFromEuler(c),h.setQuaternionAt(i,b);this.el.getObject3D(d).needsUpdate('quaternion')}}}}()});

},{"./plotutils":26}],24:[function(require,module,exports){
'use strict';var TweenArray=require('tween-array'),ease=require('eases/cubic-in-out');AFRAME.registerComponent('mod-oscillate',{schema:{layer:{default:'layer-point'},x:{type:'array'},y:{type:'array'},z:{type:'array'},duration:{default:1e3}},init:function(){this.tweenOpts={ease:ease},this.forwards=new Map,this.reverse=new Map},update:function(){this.tweenOpts.duration=this.data.duration,this.targetLayer=this.el.components[this.data.layer];this.targetLayer&&this.el.addEventListener('layer-updated',this.setupTweens.bind(this))},tick:function(a,b){if(this[this.direction]){let a;for(a of this[this.direction])a[1].tick(b),this.el.getObject3D(a[0]).needsUpdate('position');if(!a[1].active){this.direction='forwards'===this.direction?'reverse':'forwards';for(a of this[this.direction])a[1].time=0,a[1].active=!0}}},setupTweens:function(){this.forwards.clear();for(let[a,b]of this.targetLayer.lastGroups){let c=this.el.getObject3D(a).geometry.attributes.instancePosition.array,d=c.slice(),e=c.slice();for(let a,c,e=0;e<b.length;e++)a=b[e],c=3*e,d[c]=this.data.x[a]||this.data.x[0]||d[c],d[c+1]=this.data.y[a]||this.data.y[0]||d[c+1],d[c+2]=this.data.z[a]||this.data.z[0]||d[c+2];this.tweenOpts.start=e,this.forwards.set(a,new TweenArray(c,d,this.tweenOpts)),this.tweenOpts.start=d,this.reverse.set(a,new TweenArray(c,e,this.tweenOpts))}this.direction='forwards'}});

},{"eases/cubic-in-out":2,"tween-array":17}],25:[function(require,module,exports){
'use strict';AFRAME.registerComponent('plot',{schema:{},dependencies:['theme','geometry','scale-shape'],init:function(){const a=this.el.querySelectorAll('[guide-legend]');for(let b,c=0;c<a.length;c++)b=a[c].components.theme.getTheme(),a[c].setAttribute('position',{x:-0.5-b.guideWidth/2,y:0.5-1*c/a.length-b.guideHeight/2,z:-0.5-b.guideWidth/2}),a[c].setAttribute('rotation','y',-45);const b=this.el.sceneEl.querySelector('a-assets')||this.el.sceneEl.appendChild(document.createElement('a-assets')),c=document.createElement('a-mixin');c.setAttribute('id','ggaframedefaultplotmaterial'),c.setAttribute('material','side: back; transparent: true; opacity: 0.5; color: #777'),b.appendChild(c),this.scales=new Map,this.scales.set('shape',this.el.components['scale-shape'])},play:function(){const a=this.el.getAttribute('mixin');a?-1===a.indexOf('ggaframedefaultplotmaterial')&&this.el.setAttribute('mixin','ggaframedefaultplotmaterial '+a):this.el.setAttribute('mixin','ggaframedefaultplotmaterial')},registerScale:function(a,b){this.scales.get(a)&&console.warn('Replacing exisitng scale for '+a),this.scales.set(a,b)}});

},{}],26:[function(require,module,exports){
'use strict';module.exports.makeGeometry=function(a,b){const c={primitive:a};return'sphere'===a?c.radius=b:'tetrahedron'===a?c.radius=2.01*b:'octahedron'===a?c.radius=1.47*b:'dodecahedron'===a?c.radius=1.15*b:'icosahedron'===a?c.radius=1.18*b:'box'===a?c.width=c.height=c.depth=1.61*b:'cone'===a?(c.height=2*b,c.radiusBottom=b,c.radiusTop=1e-3):'cylinder'===a?(c.height=2*b,c.radius=b):'torus'===a?(c.radius=0.75*b,c.radiusTubular=0.15*b):'torusKnot'===a?(c.radius=0.6*b,c.radiusTubular=0.1*b):void 0,c.buffer=!1,c},module.exports.makeThreeGeometry=function(a,b){let c;return'sphere'===a?c=new THREE.SphereBufferGeometry(b,16,16):'tetrahedron'===a?c=new THREE.TetrahedronBufferGeometry(2.01*b):'octahedron'===a?c=new THREE.OctahedronBufferGeometry(1.47*b):'dodecahedron'===a?c=new THREE.DodecahedronBufferGeometry(1.15*b):'icosahedron'===a?c=new THREE.IcosahedronBufferGeometry(1.18*b):'box'===a?(b*=1.61,c=new THREE.BoxBufferGeometry(b,b,b)):'cone'===a?c=new THREE.ConeBufferGeometry(b,2*b,24,6):'cylinder'===a?c=new THREE.CylinderBufferGeometry(b,b,2*b,24):'torus'===a?c=new THREE.TorusBufferGeometry(0.75*b,0.3*b,12,24):'torusKnot'===a?c=new THREE.TorusKnotBufferGeometry(0.6*b,0.2*b,36,12):void 0,c},module.exports.makeMaterial=function(a){return{color:a}},module.exports.findGeometryGroups=function(a,b,c){const d=new Map;let e,f;Array.isArray(a)?1===a.length&&(e=a[0]):e=a,Array.isArray(b)?1===b.length&&(f=b[0]):f=b;for(let g=0;g<c;g++){const c=(e||a[g])+(f||b[g]);let h=d.get(c);h||(h=[],d.set(c,h)),h.push(g)}return d},module.exports.getPlot=function(a){return new Promise(function(b,c){function d(){for(;a&&!a.getAttribute('plot');)a=a.parentElement;const d=a&&a.components.plot;d?b(d):c(new Error('Unable to locate parent plot'))}a.sceneEl.hasLoaded?d():a.sceneEl.addEventListener('loaded',()=>d(),{once:!0})})};

},{}],27:[function(require,module,exports){
'use strict';AFRAME.registerComponent('scale-shape',{schema:{default:'primitive',oneOf:['identity','primitive','spinnable','sizable','platonic']},init:function(){this.breaks=[],this.labels=[],this.legendInfo={breaks:this.breaks,labels:this.labels},this.levels=new Map,this.scaled=[]},scale:function(a){const b=this.levels,c=this.scaled;if(b.clear(),'identity'===this.data||0===a.length)return a;c.length=a.length;let d=this[this.data];for(let e,f=0;f<a.length;f++){if(e=b.get(a[f]),!e){if(e=d[b.size],null==e)throw new Error('scale-shape: too many levels');b.set(a[f],e)}c[f]=e}return c},getScaleInfo:function(){this.breaks.length=this.labels.length=this.levels.size;var a=0;for(let[b,c]of this.levels)this.breaks[a]=c.toString(),this.labels[a]=b.toString(),a++;return this.legendInfo},primitive:['sphere','box','cone','torus','torusKnot','cylinder','tetrahedron','octahedron','dodecahedron','icosahedron'],spinnable:['tetrahedron','box','octahedron','dodecahedron','icosahedron','torus'],sizable:['sphere','box','icosahedron','dodecahedron','octahedron','tetrahedron'],platonic:['tetrahedron','box','octahedron','dodecahedron','icosahedron']});

},{}],28:[function(require,module,exports){
'use strict';AFRAME.registerComponent('theme',{schema:{size:{default:0.01},shape:{default:'sphere'},color:{default:'#333'},spin:{default:0},font:{default:'roboto'},fontScale:{default:0.75},fontColor:{default:'#000'},guideWidth:{default:0.3},guideHeight:{default:0.3},guideMargin:{default:0.01}},getTheme:function(){return this.data}});

},{}]},{},[1]);
